% \iffalse meta-comment
%
%% File: l3cctab.dtx
%
% Copyright (C) 2018-2020 The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    http://www.latex-project.org/lppl.txt
%
% This file is part of the "l3kernel bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/latex3
%
% for those people who are interested.
%
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3cctab} package\\ Category code tables^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released 2020-06-18}
%
% \maketitle
%
% \begin{documentation}
%
% A category code table enables rapid switching of all category codes in
% one operation. For \LuaTeX{}, this is possible over the entire Unicode
% range. For other engines, only the $8$-bit range ($0$--$255$) is covered by
% such tables.
%
% \section{Creating and initialising category code tables}
%
% \begin{function}{\cctab_new:N,\cctab_new:c}
%   \begin{syntax}
%     \cs{cctab_new:N} \meta{category code table}
%   \end{syntax}
%   Creates a new \meta{category code table} variable or raises an error if
%   the name is already taken. The declaration is global.  The
%   \meta{category code table} is initialised with the codes
%   as used by \IniTeX{}.
% \end{function}
%
% \begin{function}{\cctab_const:Nn,\cctab_const:cn}
%   \begin{syntax}
%     \cs{cctab_const:Nn} \meta{category code table} \Arg{category code set up}
%   \end{syntax}
%   Creates a new \meta{category code table} with the category code settings in
%   force at the time the function is called, and applies (in a group) the
%   \meta{category code set up} on top of prevailing settings, then saves them
%   globally as a constant table.
% \end{function}
%
% \begin{function}{\cctab_gset:Nn,\cctab_gset:cn}
%   \begin{syntax}
%     \cs{cctab_gset:Nn} \meta{category code table} \Arg{category code set up}
%   \end{syntax}
%   Applies (in a group) the \meta{category code set up} on top of
%   prevailing category code settings, then saves them globally in the
%   \meta{category code table}. Thus within a standard code block
%   the starting point will be the code applied by \cs{c_code_cctab}.
%   The assignment of the table is global: the underlying primitive does
%   not respect grouping.
% \end{function}
%
% \section{Using category code tables}
%
% \begin{function}{\cctab_begin:N,\cctab_begin:c}
%   \begin{syntax}
%     \cs{cctab_begin:N} \meta{category code table}
%   \end{syntax}
%   Switches locally the category codes in force to those stored in the
%   \meta{category code table}.  The prevailing codes before the
%   function is called are added to a stack, for use with
%   \cs{cctab_end:}. This function does not start a \TeX{} group.
% \end{function}
%
% \begin{function}{\cctab_end:}
%   \begin{syntax}
%     \cs{cctab_end:}
%   \end{syntax}
%   Ends the scope of a \meta{category code table} started using
%   \cs{cctab_begin:N}, returning the codes to those in force before the
%   matching \cs{cctab_begin:N} was used.  This must be used within the
%   same \TeX{} group (and at the same \TeX{} group level) as the
%   matching \cs{cctab_begin:N}.
% \end{function}
%
% \begin{function}[added = 2020-05-19]{\cctab_select:N}
%   \begin{syntax}
%     \cs{cctab_select:N} \meta{category code table}
%   \end{syntax}
%   Selects the \meta{category code table} for the scope of the current
%   group.
% \end{function}
%
% \section{Category code table conditionals}
%
% \begin{function}[pTF]{\cctab_if_exist:N,\cctab_if_exist:c}
%   \begin{syntax}
%     \cs{cctab_if_exist_p:N} \meta{category code table}
%     \cs{cctab_if_exist:NTF} \meta{category code table} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests whether the \meta{category code table} is currently defined.
%   This does not check that the \meta{category code table} really is a
%   category code table.
% \end{function}
%
% \section{Constant category code tables}
%
% \begin{variable}{\c_code_cctab}
%   Category code table for the code environment. This does not include
%   setting the behaviour of the line-end character, which is only
%   altered by \cs{ExplSyntaxOn}.
% \end{variable}
%
% \begin{variable}{\c_document_cctab}
%   Category code table for a standard \LaTeX{} document. This does not
%   include setting the behaviour of the line-end character, which is
%   only altered by \cs{ExplSyntaxOff}.
% \end{variable}
%
% \begin{variable}{\c_initex_cctab}
%   Category code table as set up by \IniTeX{}.
% \end{variable}
%
% \begin{variable}{\c_other_cctab}
%   Category code table where all characters have category code $12$
%   (other).
% \end{variable}
%
% \begin{variable}{\c_str_cctab}
%   Category code table where all characters have category code $12$
%   (other) with the exception of spaces, which have category code
%   $10$ (space).
% \end{variable}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3cctab} implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=cctab>
%    \end{macrocode}
%
% \begin{variable}{\g_@@_allocate_int}
% \begin{variable}{\g_@@_stack_int}
% \begin{variable}{\g_@@_stack_seq}
%   To allocate category code tables, both the read-only and stack
%   tables need to be followed. There is also a sequence stack for the
%   dynamic tables themselves.
%    \begin{macrocode}
\int_new:N  \g_@@_allocate_int
\int_gset:Nn \g_@@_allocate_int { -1 }
\int_new:N \g_@@_stack_int
\seq_new:N \g_@@_stack_seq
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \end{variable}
%
% \begin{variable}{\l_@@_tmp_tl}
%   Scratch space.
%    \begin{macrocode}
\tl_new:N \l_@@_tmp_tl
%    \end{macrocode}
% \end{variable}
%
% \subsection{Category code table engine-dependent code}
%
% \begin{macro}
%   {
%     \cctab_new:N, \cctab_new:c, \@@_begin:N, \@@_begin_aux:N,
%     \@@_end:, \@@_select:N, \@@_end_fast:, \@@_gset:N
%   }
%   As \LuaTeX{} offers engine support for category code tables, and this is
%   entirely lacking from the other engines, we need two complementary
%   approaches here. Rather than intermix them, we split the set up based on
%   engine. (Some future \XeTeX{} may add support, at which point the
%   conditional here would be subtly different.)
%
%   First, the \LuaTeX{} case.
%    \begin{macrocode}
\sys_if_engine_luatex:TF
  {
%    \end{macrocode}
%   Creating a new category code table is done slightly differently
%   from other registers. Low-numbered tables are more efficiently-stored
%   than high-numbered ones. There is also a need to have a stack of
%   flexible tables as well as the set of read-only ones. To satisfy both
%   of these requirements, odd numbered tables are used for read-only
%   tables, and even ones for the stack. Here, therefore, the odd numbers
%   are allocated.
%    \begin{macrocode}
    \cs_new_protected:Npn \cctab_new:N #1
      {
        \__kernel_chk_if_free_cs:N #1
%<*initex>
        \int_gadd:Nn \g_@@_allocate_int { 2 }
        \int_compare:nNnTF
          \g_@@_allocate_int > \c_max_register_int
           {
             \__kernel_msg_fatal:nnx
               { kernel } { out-of-registers } { cctab }
           }
           {
             \tex_global:D \tex_chardef:D #1 \g_@@_allocate_int
             \tex_initcatcodetable:D #1
           }
%</initex>
%<*package>
        \newcatcodetable #1
%</package>
      }
%    \end{macrocode}
%   The aim here is to ensure that the saved tables are read-only. This is
%   done by using a stack of tables which are not read only, and actually
%   having them as \enquote{in use} copies.
%    \begin{macrocode}
    \cs_new_protected:Npn \@@_begin:N #1
      {
        \seq_gpush:Nx \g_@@_stack_seq { \tex_the:D \tex_catcodetable:D }
        \tex_catcodetable:D #1
        \int_gadd:Nn \g_@@_stack_int { 2 }
        \int_compare:nNnT \g_@@_stack_int > \c_max_register_int
          { \__kernel_msg_fatal:nn { kernel } { cctab-stack-full } }
        \tex_savecatcodetable:D \g_@@_stack_int
        \tex_catcodetable:D \g_@@_stack_int
      }
    \cs_new_protected:Npn \@@_end:
      {
        \int_gsub:Nn \g_@@_stack_int { 2 }
        \seq_gpop:NNF \g_@@_stack_seq \l_@@_tmp_tl
          { \tl_set:Nn \l_@@_tmp_tl { 0 } }
        \tex_catcodetable:D \l_@@_tmp_tl \scan_stop:
      }
    \cs_new_protected:Npn \@@_select:N #1
      {
        \@@_begin:N #1
        \group_insert_after:N \@@_end_fast:
      }
    \cs_new_protected:Npn \@@_end_fast:
      {
        \int_gsub:Nn \g_@@_stack_int { 2 }
        \seq_gpop:NN \g_@@_stack_seq \l_@@_tmp_tl
      }
    \cs_new_eq:NN \@@_gset:N \tex_savecatcodetable:D
  }
%    \end{macrocode}
%   Now the case for other engines. Here, each table is an integer
%   array.  The index base is out-by-one, so we have an internal
%   function to handle that. The rest of the approach here is pretty
%   simple: use a stack of tables, and save to them at each
%   |begin|. Unlike the \LuaTeX{} case, we can't accidentally alter a
%   saved table, which makes life a little easier.  Following the
%   \LuaTeX{} pattern, a new table starts with \IniTeX{} codes.
%    \begin{macrocode}
  {
    \cs_new_protected:Npn \@@_gstore:Nnn #1#2#3
      { \intarray_gset:Nnn #1 { \int_eval:n { #2 + 1 } } {#3} }
    \cs_new_protected:Npn \cctab_new:N #1
      {
        \intarray_new:Nn #1 { 256 }
        \int_step_inline:nn { 256 }
          { \__kernel_intarray_gset:Nnn #1 {##1} { 12 } }
        \@@_gstore:Nnn #1 { 0 } { 9 }
        \@@_gstore:Nnn #1 { 13 } { 5 }
        \@@_gstore:Nnn #1 { 32 } { 10 }
        \@@_gstore:Nnn #1 { 37 } { 14 }
        \int_step_inline:nnn { 65 } { 90 }
          { \@@_gstore:Nnn #1 {##1} { 11 } }
        \@@_gstore:Nnn #1 { 92 } { 0 }
        \int_step_inline:nnn { 97 } { 122 }
          { \@@_gstore:Nnn #1 {##1} { 11 } }
        \@@_gstore:Nnn #1 { 127 } { 15 }
      }
%    \end{macrocode}
%   Then we implement two basic operations: setting catcodes (selecting
%   a catcode table) and saving catcodes (assigning a catcode table).
%    \begin{macrocode}
    \cs_new_protected:Npn \@@_select:N #1
      {
        \int_step_inline:nn { 256 }
          {
            \char_set_catcode:nn { ##1 - 1 }
              { \__kernel_intarray_item:Nn #1 {##1} }
          }
      }
    \cs_new_protected:Npn \@@_gset:N #1
      {
        \int_step_inline:nn { 256 }
          {
            \__kernel_intarray_gset:Nnn #1 {##1}
              { \char_value_catcode:n { ##1 - 1 } }
          }
      }
%    \end{macrocode}
%   Beginning and ending a catcode table simply involves
%   some bookkeeping to store the current catcodes in a
%   dynamically generated variable.
%    \begin{macrocode}
    \cs_new_protected:Npn \@@_begin:N #1
      {
        \int_gadd:Nn \g_@@_stack_int { 2 }
        \exp_args:Nc \@@_begin_aux:N
          { g_@@_ \int_use:N \g_@@_stack_int _intarray }
        \@@_select:N #1
      }
    \cs_new_protected:Npn \@@_begin_aux:N #1
      {
        \cs_if_exist:NF #1 { \intarray_new:Nn #1 { 256 } }
        \@@_gset:N #1
      }
    \cs_new_protected:Npn \@@_end:
      {
        \exp_args:Nc \@@_select:N
          { g_@@_ \int_use:N \g_@@_stack_int _intarray }
        \int_gsub:Nn \g_@@_stack_int { 2 }
      }
%    \end{macrocode}
%   Beginning and ending a catcode table simply involves
%   some bookkeeping to store the current catcodes in a
%   dynamically generated variable.
%    \begin{macrocode}
  }
\cs_generate_variant:Nn \cctab_new:N { c }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Using category code tables}
%
% \begin{macro}{\cctab_select:N, \cctab_select:c}
% \begin{macro}{\cctab_begin:N, \cctab_begin:c}
% \begin{macro}{\cctab_end:}
%   These functions perform a few sanity checks before calling internal
%   functions defined below, which do the engine-dependent
%   heavy-lifting.  The first two functions check if a \meta{cctab~var}
%   exists before trying to use it while \cs{cctab_end:} checks if a
%   \cs{cctab_begin:N} was used some time earlier.  Skipping these
%   checks would result in low-level engine-dependent errors.
%    \begin{macrocode}
\cs_new_protected:Npn \cctab_select:N #1
  { \@@_chk_if_valid:NT #1 { \@@_select:N #1 } }
\cs_generate_variant:Nn \cctab_select:N { c }
\cs_new_protected:Npn \cctab_begin:N #1
  { \@@_chk_if_valid:NT #1 { \@@_begin:N #1 } }
\cs_generate_variant:Nn \cctab_begin:N { c }
\cs_new_protected:Npn \cctab_end:
  {
    \int_compare:nNnTF { \g_@@_stack_int } = { \c_zero_int }
      { \__kernel_msg_error:nn { kernel } { cctab-extra-end } }
      { \@@_end: }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\cctab_gset:Nn, \cctab_gset:cn}
%   Category code tables are always global, so only one version of
%   assignments is needed.  Simply run the setup in a group and save the
%   result in a category code table~|#1|, provided it is valid.  The
%   internal function is defined below depending on the engine.
%    \begin{macrocode}
\cs_new_protected:Npn \cctab_gset:Nn #1#2
  {
    \@@_chk_if_valid:NT #1
      {
        \group_begin:
          #2 \scan_stop:
          \@@_gset:N #1
        \group_end:
      }
  }
\cs_generate_variant:Nn \cctab_gset:Nn { c }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Category code table conditionals}
%
% \begin{macro}{\cctab_if_exist:N,\cctab_if_exist:c}
%   Checks whether a \meta{cctab~var} is defined.
%    \begin{macrocode}
\prg_new_eq_conditional:NNn \cctab_if_exist:N \cs_if_exist:N
  { TF , T , F , p }
\prg_new_eq_conditional:NNn \cctab_if_exist:c \cs_if_exist:c
  { TF , T , F , p }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_chk_if_valid:N}
%   Checks whether the argument is defined and whether it is a valid
%   \meta{cctab~var}. In \LuaTeX{} the validity of the \meta{cctab~var}
%   is checked by the engine, which complains if the argument is not a
%   \cs{chardef}'ed constant. In other engines, check if the given
%   command is an intarray variable (the underlying definition is a copy
%   of the \texttt{cmr10} font).
%    \begin{macrocode}
\sys_if_engine_luatex:TF
  {
    \prg_new_protected_conditional:Npnn \@@_chk_if_valid:N #1
      { TF , T , F }
      {
        \cctab_if_exist:NTF #1
          {
%<*initex>
            \bool_lazy_and:nnTF
              { \int_if_odd_p:n {#1} }
              { \int_compare_p:nNn {#1-1} < { \g_@@_allocate_int } }
%</initex>
%<*package>
            \int_compare:nNnTF {#1-1} < { \e@alloc@ccodetable@count }
%</package>
              { \prg_return_true: }
              {
                \__kernel_msg_error:nnx { kernel } { invalid-cctab }
                  { \token_to_str:N #1 }
                \prg_return_false:
              }
          }
          {
            \__kernel_msg_error:nnx { kernel } { command-not-defined }
              { \token_to_str:N #1 }
            \prg_return_false:
          }
      }
  }
  {
    \prg_new_protected_conditional:Npnn \@@_chk_if_valid:N #1
      { TF , T , F }
      {
        \cctab_if_exist:NTF #1
          {
            \exp_args:Nf \str_if_in:nnTF
              { \cs_meaning:N #1 }
              { select~font~cmr10~at~ }
              { \prg_return_true: }
              {
                \__kernel_msg_error:nnx { kernel } { invalid-cctab }
                  { \token_to_str:N #1 }
                \prg_return_false:
              }
          }
          {
            \__kernel_msg_error:nnx { kernel } { command-not-defined }
              { \token_to_str:N #1 }
            \prg_return_false:
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cctab_const:Nn,\cctab_const:cn}
%  Creates a new \meta{cctab~var} then sets it with the current and
%  user-supplied codes.
%    \begin{macrocode}
\cs_new_protected:Npn \cctab_const:Nn #1#2
  {
    \cctab_new:N #1
    \cctab_gset:Nn #1 {#2}
  }
\cs_generate_variant:Nn \cctab_const:Nn { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}
%   {
%     \c_initex_cctab   ,
%     \c_code_cctab     ,
%     \c_document_cctab ,
%     \c_other_cctab    ,
%     \c_str_cctab
%   }  
%   Creating category code tables is easy using the function above.
%   The \texttt{other} and \texttt{string} ones are done by completely
%   ignoring the existing codes as this makes life a lot less complex.
%    \begin{macrocode}
\cctab_new:N \c_initex_cctab
\cctab_const:Nn \c_code_cctab { }
\cctab_const:Nn \c_document_cctab
  {
    \char_set_catcode_space:n          { 9 }
    \char_set_catcode_space:n          { 32 }
    \char_set_catcode_other:n          { 58 }
    \char_set_catcode_math_subscript:n { 95 }
    \char_set_catcode_active:n         { 126 }
  }
\cctab_const:Nn \c_other_cctab
  {
    \int_step_inline:nnn { 0 } { 127 }
      { \char_set_catcode_other:n {#1} }
  }
\cctab_const:Nn \c_str_cctab
  {
    \int_step_inline:nnn { 0 } { 127 }
      { \char_set_catcode_other:n {#1} }
    \char_set_catcode_space:n { 32 }
  }
%    \end{macrocode}
% \end{variable}
%
% \subsection{Messages}
%
%    \begin{macrocode}
\__kernel_msg_new:nnnn { kernel } { cctab-stack-full }
  { The~category~code~table~stack~is~exhausted. }
  {
    LaTeX~has~been~asked~to~switch~to~a~new~category~code~table,~
    but~there~is~no~more~space~to~do~this!
  }
\__kernel_msg_new:nnnn { kernel } { cctab-extra-end }
  { Extra~\iow_char:N\\cctab_end:~ignored~\msg_line_context:. }
  {
    LaTeX~came~across~a~\iow_char:N\\cctab_end:~without~a~matching~
    \iow_char:N\\cctab_begin:N.~This~command~will~be~ignored.
  }
\__kernel_msg_new:nnnn { kernel } { invalid-cctab }
  { Invalid~\iow_char:N\\catcode~table. }
  {
    You~can~only~switch~to~a~\iow_char:N\\catcode~table~that~is~
    initialized~using~\iow_char:N\\cctab_new:N~or~
    \iow_char:N\\cctab_const:Nn.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
%\PrintIndex
